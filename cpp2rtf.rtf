{\rtf1\ansi
{\fonttbl\f0\fmodern Courier;\f1\froman Times;}
{\f0 #{\f1\b include} <{\f1\i array}>\line
#{\f1\b include} <{\f1\i cstdlib}>\line
#{\f1\b include} <{\f1\i functional}>\line
#{\f1\b include} <{\f1\i iostream}>\line
#{\f1\b include} <{\f1\i memory}>\line
#{\f1\b include} <{\f1\i set}>\line
#{\f1\b include} <{\f1\i sstream}>\line
#{\f1\b include} <{\f1\i string}>\line
#{\f1\b include} <{\f1\i typeinfo}>\line
#{\f1\b include} <{\f1\i vector}>\line
\line
{\f1\b bool} {\f1\i debug}\{{\f1\b true}\};\line
\line
{\f1\b const} {\f1\i std}::{\f1\i string} {\f1\i id_1st_chars}\{\line
		"{\f1\i abcdefghijklmnopqrstuvwxyz}"\line
		"{\f1\i ABCDEFGHIJKLMNOPQRSTUVWXYZ}"\line
		"{\f1\i _}"\};\line
{\f1\b const} {\f1\i std}::{\f1\i string} {\f1\i id_chars}\{{\f1\i id_1st_chars} + "{\f1\i 0123456789}"\};\line
\line
{\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}> {\f1\i c_keywords}\{\line
    "{\f1\i auto}", "{\f1\i break}", "{\f1\i case}", "{\f1\i char}", "{\f1\i const}", "{\f1\i continue}", "{\f1\i default}", "{\f1\i do}",\line
    "{\f1\i double}", "{\f1\i else}", "{\f1\i enum}", "{\f1\i extern}", "{\f1\i float}", "{\f1\i for}", "{\f1\i goto}", "{\f1\i if}", "{\f1\i inline}",\line
    "{\f1\i int}", "{\f1\i long}", "{\f1\i register}", "{\f1\i restrict}", "{\f1\i return}", "{\f1\i short}", "{\f1\i signed}",\line
    "{\f1\i sizeof}", "{\f1\i static}", "{\f1\i struct}", "{\f1\i switch}", "{\f1\i typedef}", "{\f1\i union}", "{\f1\i unsigned}",\line
    "{\f1\i void}", "{\f1\i volatile}", "{\f1\i while}", "{\f1\i _Alignas}", "{\f1\i _Alignof}", "{\f1\i _Atomic}", "{\f1\i _Bool}",\line
    "{\f1\i _Complex}", "{\f1\i _Generic}", "{\f1\i _Imaginary}", "{\f1\i _Noreturn}", "{\f1\i _Static_assert}",\line
    "{\f1\i _Thread_local}"\line
\};\line
\line
{\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}> {\f1\i cpp_keywords}\{\line
    "{\f1\i asm}", "{\f1\i dynamic_cast}", "{\f1\i namespace}", "{\f1\i reinterpret_cast}", "{\f1\i try}", "{\f1\i bool}",\line
    "{\f1\i explicit}", "{\f1\i new}", "{\f1\i static_cast}", "{\f1\i typeid}", "{\f1\i catch}", "{\f1\i false}", "{\f1\i operator}",\line
    "{\f1\i template}", "{\f1\i typename}", "{\f1\i class}", "{\f1\i friend}", "{\f1\i private}", "{\f1\i this}", "{\f1\i using}",\line
    "{\f1\i const_cast}", "{\f1\i inline}", "{\f1\i public}", "{\f1\i throw}", "{\f1\i virtual}", "{\f1\i delete}", "{\f1\i mutable}",\line
    "{\f1\i protected}", "{\f1\i true}", "{\f1\i wchar_t}", "{\f1\i and}", "{\f1\i bitand}", "{\f1\i compl}", "{\f1\i not_eq}", "{\f1\i or_eq}",\line
    "{\f1\i xor_eq}", "{\f1\i and_eq}", "{\f1\i bitor}", "{\f1\i not}", "{\f1\i or}", "{\f1\i xor}", "{\f1\i alignas}", "{\f1\i alignof}",\line
    "{\f1\i char16_t}", "{\f1\i char32_t}", "{\f1\i constexpr}", "{\f1\i decltype}", "{\f1\i noexcept}", "{\f1\i nullptr}",\line
    "{\f1\i static_assert}", "{\f1\i thread_local}"\line
\};\line
\line
//{\f1\i Is there a better way to do this?}\line
{\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}> {\f1\i set_union}(\line
        {\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}>& {\f1\i a},\line
        {\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}>& {\f1\i b})\line
\{\line
    {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}> {\f1\i c}\{{\f1\i a}\};\line
    {\f1\i c}.{\f1\i insert}({\f1\i b}.{\f1\i begin}(), {\f1\i b}.{\f1\i end}());\line
    {\f1\b return} {\f1\i c};\line
\}\line
\line
{\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}> {\f1\i all_keywords}\{{\f1\i set_union}({\f1\i c_keywords}, {\f1\i cpp_keywords})\};\line
\line
//{\f1\i This class is both a base class and used for text with default formatting.}\line
{\f1\b class} {\f1\i Text_run} \{\line
    {\f1\b public}:\line
        {\f1\b static} {\f1\i std}::{\f1\i string} {\f1\i escape}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text});\line
\line
        {\f1\i Text_run}() \{\}\line
        {\f1\i Text_run}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text}): {\f1\i text_}({\f1\i text}) \{\}\line
        {\f1\i std}::{\f1\i string} {\f1\i get_text}() {\f1\b const} \{ {\f1\b return} {\f1\i text_}; \}\line
\line
        {\f1\b void} {\f1\i print}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\b if} ({\f1\i debug}) \{\line
                {\f1\i std}::{\f1\i cerr} << {\f1\b typeid}(*{\f1\b this}).{\f1\i name}() << "{\f1\i : \\"}" << {\f1\i text_} << "{\f1\i \\"}" <<\line
                    {\f1\i std}::{\f1\i endl};\line
            \}\line
            {\f1\i print_}({\f1\i out});\line
        \}\line
\line
    {\f1\b protected}:\line
        {\f1\b virtual} {\f1\b void} {\f1\i print_}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\i out} << {\f1\i escape}({\f1\i text_});\line
        \}\line
\line
    {\f1\b private}:\line
        {\f1\i std}::{\f1\i string} {\f1\i text_};\line
\};\line
\line
{\f1\b class} {\f1\i Char_literal}: {\f1\b public} {\f1\i Text_run} \{\line
    {\f1\b public}:\line
        {\f1\i Char_literal}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text})\line
            : {\f1\i Text_run}({\f1\i text}.{\f1\i substr}(1, {\f1\i text}.{\f1\i size}() - 2)) \{\}\line
    {\f1\b protected}:\line
        {\f1\b virtual} {\f1\b void} {\f1\i print_}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\i out} << '{\f1\i \\'}';\line
            {\f1\i out} << "{\f1\i \{\\\\f1\\\\i }";\line
            {\f1\i out} << {\f1\i escape}({\f1\i get_text}());\line
            {\f1\i out} << "{\f1\i \}}";\line
            {\f1\i out} << '{\f1\i \\'}';\line
        \}\line
\};\line
\line
{\f1\b class} {\f1\i String_literal}: {\f1\b public} {\f1\i Text_run} \{\line
    {\f1\b public}:\line
        {\f1\i String_literal}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text})\line
            : {\f1\i Text_run}({\f1\i text}.{\f1\i substr}(1, {\f1\i text}.{\f1\i size}() - 2)) \{\}\line
    {\f1\b protected}:\line
        {\f1\b virtual} {\f1\b void} {\f1\i print_}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\i out} << '{\f1\i "}';\line
            {\f1\i out} << "{\f1\i \{\\\\f1\\\\i }";\line
            {\f1\i out} << {\f1\i escape}({\f1\i get_text}());\line
            {\f1\i out} << "{\f1\i \}}";\line
            {\f1\i out} << '{\f1\i "}';\line
        \}\line
\};\line
\line
{\f1\b class} {\f1\i Single_line_comment}: {\f1\b public} {\f1\i Text_run} \{\line
    {\f1\b public}:\line
        {\f1\i Single_line_comment}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text})\line
            : {\f1\i Text_run}({\f1\i text}.{\f1\i substr}(2)) \{\}\line
    {\f1\b protected}:\line
        {\f1\b virtual} {\f1\b void} {\f1\i print_}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\i out} << "{\f1\i //}";\line
            {\f1\i out} << "{\f1\i \{\\\\f1\\\\i }";\line
            {\f1\i out} << {\f1\i escape}({\f1\i get_text}());\line
            {\f1\i out} << "{\f1\i \}}";\line
        \}\line
\};\line
\line
{\f1\b class} {\f1\i Multiline_comment}: {\f1\b public} {\f1\i Text_run} \{\line
    {\f1\b public}:\line
        {\f1\b enum} {\f1\i Kind} \{ {\f1\i complete}, {\f1\i start}, {\f1\i middle}, {\f1\i end} \};\line
        {\f1\i Multiline_comment}({\f1\i Kind} {\f1\i kind}, {\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text})\line
            : {\f1\i Text_run}({\f1\i text}), {\f1\i kind_}({\f1\i kind}) \{\}\line
    {\f1\b protected}:\line
        {\f1\b virtual} {\f1\b void} {\f1\i print_}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\b if} (({\f1\i kind_} == {\f1\i complete}) || ({\f1\i kind_} == {\f1\i start})) {\f1\i out} << "{\f1\i /*}";\line
            {\f1\i out} << "{\f1\i \{\\\\f1\\\\i }";\line
            {\f1\i out} << {\f1\i escape}({\f1\i get_text}());\line
            {\f1\i out} << "{\f1\i \}}";\line
            {\f1\b if} (({\f1\i kind_} == {\f1\i complete}) || ({\f1\i kind_} == {\f1\i end})) {\f1\i out} << "{\f1\i */}";\line
        \}\line
    {\f1\b private}:\line
        {\f1\i Kind} {\f1\i kind_};\line
\};\line
\line
//{\f1\i Identifiers that aren't preproc directives or keywords.}\line
{\f1\b class} {\f1\i Identifier}: {\f1\b public} {\f1\i Text_run} \{\line
    {\f1\b public}:\line
        {\f1\i Identifier}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text})\line
            : {\f1\i Text_run}({\f1\i text}) \{\}\line
    {\f1\b protected}:\line
        {\f1\b virtual} {\f1\b void} {\f1\i print_}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\i out} << "{\f1\i \{\\\\f1\\\\i }";\line
            {\f1\i out} << {\f1\i escape}({\f1\i get_text}());\line
            {\f1\i out} << "{\f1\i \}}";\line
        \}\line
\};\line
\line
{\f1\b class} {\f1\i Keyword}: {\f1\b public} {\f1\i Text_run} \{\line
    {\f1\b public}:\line
        {\f1\i Keyword}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i text}): {\f1\i Text_run}({\f1\i text}) \{\}\line
    {\f1\b protected}:\line
        {\f1\b virtual} {\f1\b void} {\f1\i print_}({\f1\i std}::{\f1\i ostream}& {\f1\i out}) {\f1\b const}\line
        \{\line
            {\f1\i out} << "{\f1\i \{\\\\f1\\\\b }";\line
            {\f1\i out} << {\f1\i escape}({\f1\i get_text}());\line
            {\f1\i out} << "{\f1\i \}}";\line
        \}\line
\};\line
\line
{\f1\i std}::{\f1\i string} {\f1\i Text_run}::{\f1\i escape}({\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i in})\line
\{\line
    {\f1\i std}::{\f1\i ostringstream} {\f1\i out};\line
    {\f1\b for} ({\f1\b auto} {\f1\i i}: {\f1\i in}) \{\line
        {\f1\b if} (({\f1\i i} == '{\f1\i \\\\}') || ({\f1\i i} == '{\f1\i \{}') || ({\f1\i i} == '{\f1\i \}}'))\line
            {\f1\i out} << '{\f1\i \\\\}';\line
        {\f1\i out} << {\f1\i i};\line
    \}\line
    {\f1\b return} {\f1\i out}.{\f1\i str}();\line
\}\line
\line
//{\f1\i Find the end of a string literal.}\line
{\f1\i std}::{\f1\i string}::{\f1\i size_type} {\f1\i find_end}(\line
		{\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i s},\line
		{\f1\i std}::{\f1\i string}::{\f1\i size_type} {\f1\i start},\line
		{\f1\b char} {\f1\i end_char})\line
\{\line
	{\f1\b bool} {\f1\i ignore_next} = {\f1\b true};\line
	{\f1\b for} ({\f1\b auto} {\f1\i pos}({\f1\i start}); {\f1\i pos} < {\f1\i s}.{\f1\i size}(); ++{\f1\i pos}) \{\line
		{\f1\b if} (!{\f1\i ignore_next}) \{\line
			{\f1\b if} ({\f1\i s}[{\f1\i pos}] == {\f1\i end_char}) {\f1\b return} {\f1\i pos};\line
			{\f1\b if} ({\f1\i s}[{\f1\i pos}] == '{\f1\i \\\\}') {\f1\i ignore_next} = {\f1\b true};\line
		\} {\f1\b else} \{\line
			{\f1\i ignore_next} = {\f1\b false};\line
		\}\line
	\}\line
	{\f1\b return} {\f1\i std}::{\f1\i string}::{\f1\i npos};\line
\}\line
\line
{\f1\b static} {\f1\b bool} {\f1\i contains}(\line
        {\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}>& {\f1\i set},\line
        {\f1\b const} {\f1\i std}::{\f1\i set}<{\f1\i std}::{\f1\i string}>::{\f1\i key_type}& {\f1\i x})\line
\{\line
    //{\f1\i Could write this as a template, but I'm being lazy.}\line
    {\f1\b return} !({\f1\i set}.{\f1\i find}({\f1\i x}) == {\f1\i set}.{\f1\i end}());\line
\}\line
\line
{\f1\b bool} {\f1\i in_multiline_comment} = {\f1\b false};\line
\line
{\f1\b void} {\f1\i parse}({\f1\i std}::{\f1\i vector}<{\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>>& {\f1\i list},\line
        {\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i line}, {\f1\b bool} {\f1\i first} = {\f1\b false})\line
\{\line
    {\f1\b if} ({\f1\i in_multiline_comment}) \{\line
        {\f1\b auto} {\f1\i end}({\f1\i line}.{\f1\i find}("{\f1\i */}"));\line
        {\f1\b if} ({\f1\i end} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) \{\line
            {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>(\line
                        {\f1\b new} {\f1\i Multiline_comment}(\line
                            {\f1\i Multiline_comment}::{\f1\i end},\line
                            {\f1\i line}.{\f1\i substr}(0, {\f1\i end}))));\line
            {\f1\i in_multiline_comment} = {\f1\b false};\line
            {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}({\f1\i end} + 2));\line
        \} {\f1\b else} \{\line
            {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>(\line
                        {\f1\b new} {\f1\i Multiline_comment}(\line
                            {\f1\i Multiline_comment}::{\f1\i middle},\line
                            {\f1\i line})));\line
        \}\line
        {\f1\b return};\line
    \}\line
\line
    //{\f1\i Scan for string literals, char literals, and comments.}\line
    {\f1\b auto} {\f1\i dquote}({\f1\i line}.{\f1\i find}('{\f1\i "}'));\line
    {\f1\b auto} {\f1\i squote}({\f1\i line}.{\f1\i find}('{\f1\i \\'}'));\line
    {\f1\b auto} {\f1\i slashslash}({\f1\i line}.{\f1\i find}("{\f1\i //}"));\line
    {\f1\b auto} {\f1\i slashstar}({\f1\i line}.{\f1\i find}("{\f1\i /*}"));\line
\line
    //{\f1\i Figure out which one came first.}\line
    {\f1\i std}::{\f1\i array}<{\f1\b decltype}({\f1\i dquote}), 4> {\f1\i specials} =\line
    \{ {\f1\i dquote}, {\f1\i squote}, {\f1\i slashslash}, {\f1\i slashstar} \};\line
    {\f1\i std}::{\f1\i sort}({\f1\i specials}.{\f1\i begin}(), {\f1\i specials}.{\f1\i end}());\line
    {\f1\b const} {\f1\b auto} {\f1\i first_special} = {\f1\i specials}[0];\line
\line
    //{\f1\i Handle the first special, if any.}\line
    {\f1\b if} ({\f1\i first_special} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) \{\line
        {\f1\b if} ({\f1\i first_special} == {\f1\i squote}) \{\line
            {\f1\b auto} {\f1\i end}({\f1\i find_end}({\f1\i line}, {\f1\i squote}, '{\f1\i \\'}'));\line
            {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}(0, {\f1\i squote}), {\f1\i first});\line
            {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>({\f1\b new} {\f1\i Char_literal}(\line
                            {\f1\i line}.{\f1\i substr}({\f1\i squote}, ({\f1\i end} - {\f1\i squote}) + 1))));\line
            {\f1\b if} ({\f1\i end} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}({\f1\i end} + 1));\line
            {\f1\b return};\line
        \} {\f1\b else} {\f1\b if} ({\f1\i first_special} == {\f1\i dquote}) \{\line
            //{\f1\i Find end of string literal.}\line
            {\f1\b auto} {\f1\i end}({\f1\i find_end}({\f1\i line}, {\f1\i dquote}, '{\f1\i "}'));\line
            //{\f1\i Parse before literal.}\line
            {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}(0, {\f1\i dquote}), {\f1\i first});\line
            //{\f1\i Add literal}\line
            {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>({\f1\b new} {\f1\i String_literal}(\line
                            {\f1\i line}.{\f1\i substr}({\f1\i dquote}, ({\f1\i end} - {\f1\i dquote}) + 1))));\line
            //{\f1\i Parse after literal.}\line
            {\f1\b if} ({\f1\i end} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}({\f1\i end} + 1));\line
            //{\f1\i Done with this line.}\line
            {\f1\b return};\line
        \} {\f1\b else} {\f1\b if} ({\f1\i first_special} == {\f1\i slashslash}) \{\line
            //{\f1\i Parse beginning of line}\line
            {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}(0, {\f1\i slashslash}), {\f1\i first});\line
            //{\f1\i Add comment}\line
            {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>(\line
                        {\f1\b new} {\f1\i Single_line_comment}({\f1\i line}.{\f1\i substr}({\f1\i slashslash}))));\line
            //{\f1\i Done with this line.}\line
            {\f1\b return};\line
        \} {\f1\b else} {\f1\b if} ({\f1\i first_special} == {\f1\i slashstar}) \{\line
            {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}(0, {\f1\i slashstar}), {\f1\i first});\line
            {\f1\b auto} {\f1\i end}({\f1\i line}.{\f1\i find}("{\f1\i */}", {\f1\i slashstar} + 2));\line
            {\f1\b if} ({\f1\i end} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) \{\line
                {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>(\line
                            {\f1\b new} {\f1\i Multiline_comment}(\line
                                {\f1\i Multiline_comment}::{\f1\i complete},\line
                                {\f1\i line}.{\f1\i substr}({\f1\i slashstar} + 2,\line
                                    ({\f1\i end} - {\f1\i slashstar}) - 2))));\line
                {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}({\f1\i end} + 2));\line
            \} {\f1\b else} \{\line
                {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>(\line
                            {\f1\b new} {\f1\i Multiline_comment}(\line
                                {\f1\i Multiline_comment}::{\f1\i start},\line
                                {\f1\i line}.{\f1\i substr}({\f1\i slashstar} + 2))));\line
                {\f1\i in_multiline_comment} = {\f1\b true};\line
            \}\line
            {\f1\b return};\line
        \}\line
    \}\line
    //{\f1\i At this point, we've gotten all the char/string literals and comments.}\line
\line
    {\f1\b if} ({\f1\i first}) \{\line
        //{\f1\i Check for preproc directive}\line
        //{\f1\i [ \\t]*#[ \\t]*[A-Za-z]+}\line
        //{\f1\i Not a single object...}\line
        {\f1\i std}::{\f1\i string}::{\f1\i size_type} {\f1\i pound} = {\f1\i line}.{\f1\i find_first_not_of}("{\f1\i  \\t}");\line
        {\f1\b if} (({\f1\i pound} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) && ({\f1\i line}[{\f1\i pound}] == '{\f1\i #}')) \{\line
            {\f1\b auto} {\f1\i start} = {\f1\i line}.{\f1\i find_first_not_of}(\line
                    "{\f1\i  \\t}", {\f1\i pound} + 1);\line
            {\f1\b auto} {\f1\i end} = {\f1\i line}.{\f1\i find_first_not_of}({\f1\i id_1st_chars},\line
                    {\f1\i start} + 1);\line
            {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>(\line
                        {\f1\b new} {\f1\i Text_run}({\f1\i line}.{\f1\i substr}(0, {\f1\i start}))));\line
            {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>(\line
                        {\f1\b new} {\f1\i Keyword}({\f1\i line}.{\f1\i substr}({\f1\i start},\line
                                {\f1\i end} - {\f1\i start}))));\line
            {\f1\b if} ({\f1\i end} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) \{\line
                {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}({\f1\i end}), {\f1\b false});\line
            \}\line
            {\f1\b return};\line
        \}\line
    \}\line
\line
    //{\f1\i Find identifiers}\line
    {\f1\b auto} {\f1\i id_start} = {\f1\i line}.{\f1\i find_first_of}({\f1\i id_1st_chars});\line
    {\f1\b if} ({\f1\i id_start} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) \{\line
        {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}(0, {\f1\i id_start}), {\f1\i first});\line
        {\f1\b auto} {\f1\i id_end} = {\f1\i line}.{\f1\i find_first_not_of}({\f1\i id_chars}, {\f1\i id_start} + 1);\line
        {\f1\i std}::{\f1\i string} {\f1\i id} = {\f1\i line}.{\f1\i substr}({\f1\i id_start}, {\f1\i id_end} - {\f1\i id_start});\line
        //{\f1\i Check if identifier is a keyword.}\line
        {\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}> {\f1\i p};\line
        {\f1\b if} ({\f1\i contains}({\f1\i all_keywords}, {\f1\i id})) \{\line
            {\f1\i p}.{\f1\i reset}({\f1\b new} {\f1\i Keyword}({\f1\i id}));\line
        \} {\f1\b else} \{\line
            {\f1\i p}.{\f1\i reset}({\f1\b new} {\f1\i Identifier}({\f1\i id}));\line
        \}\line
        {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i move}({\f1\i p}));\line
        {\f1\b if} ({\f1\i id_end} != {\f1\i std}::{\f1\i string}::{\f1\i npos}) \{\line
            {\f1\i parse}({\f1\i list}, {\f1\i line}.{\f1\i substr}({\f1\i id_end}), {\f1\b false});\line
        \}\line
        {\f1\b return};\line
    \}\line
\line
    {\f1\i list}.{\f1\i push_back}({\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>({\f1\b new} {\f1\i Text_run}({\f1\i line})));\line
\}\line
\line
{\f1\b void} {\f1\i process_line}({\f1\i std}::{\f1\i ostream}& {\f1\i out}, {\f1\b const} {\f1\i std}::{\f1\i string}& {\f1\i line})\line
\{\line
    {\f1\i std}::{\f1\i vector}<{\f1\i std}::{\f1\i unique_ptr}<{\f1\i Text_run}>> {\f1\i list};\line
    {\f1\i parse}({\f1\i list}, {\f1\i line}, {\f1\b true});\line
    {\f1\b for} ({\f1\b auto} {\f1\b const}& {\f1\i i}: {\f1\i list}) {\f1\i i}->{\f1\i print}({\f1\i out});\line
    //{\f1\i Write line break.}\line
    {\f1\i out} << "{\f1\i \\\\line}" << {\f1\i std}::{\f1\i endl};\line
\line
\}\line
\line
{\f1\b void} {\f1\i process}({\f1\i std}::{\f1\i ostream}& {\f1\i out}, {\f1\i std}::{\f1\i istream}& {\f1\i in})\line
\{\line
    //{\f1\i Write header.}\line
    {\f1\i out} << "{\f1\i \{\\\\rtf1\\\\ansi}" << {\f1\i std}::{\f1\i endl};\line
    {\f1\i out} << "{\f1\i \{\\\\fonttbl\\\\f0\\\\fmodern Courier;\\\\f1\\\\froman Times;\}}" <<\line
        {\f1\i std}::{\f1\i endl};\line
    {\f1\i out} << "{\f1\i \{\\\\f0 }";\line
\line
    //{\f1\i Process lines.}\line
    {\f1\i std}::{\f1\i string} {\f1\i line};\line
    {\f1\b while} ({\f1\i std}::{\f1\i getline}({\f1\i in}, {\f1\i line})) \{\line
        {\f1\i process_line}({\f1\i out}, {\f1\i line});\line
    \}\line
\line
    //{\f1\i Write footer.}\line
    {\f1\i out} << "{\f1\i \}\}}" << {\f1\i std}::{\f1\i endl};\line
\}\line
\line
{\f1\b int} {\f1\i main}({\f1\b int} {\f1\i argc}, {\f1\b char}** {\f1\i argv})\line
\{\line
    {\f1\i process}({\f1\i std}::{\f1\i cout}, {\f1\i std}::{\f1\i cin});\line
    {\f1\b return} {\f1\i EXIT_SUCCESS};\line
\}\line
\line
}}
